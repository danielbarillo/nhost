---
title: "Auto-Embeddings"
description: "Generate embeddings for your application automatically"
---

Auto-emeddings leverages [pgvector](https://github.com/pgvector/pgvector) and [OpenAI](https://platform.openai.com/docs/guides/embeddings) to easily generate embeddings for your data in near real-time and without hassle. In addition, Auto-Embeddings allows you to seamlessly query your data using natural language or even using another object in your database (similarity search).In addtion, the embeddings generated by Auto-Embeddings can be leveraged by your own code to perform any analysis or provide any extra functionality you may need.

## Generating embeddings

Embeddings generation works in the following way:

1. Every `sync-period` (60 seconds by default) graphite queries your data and searches for new data (or existing data that changed recently).
2. It extracts the relevant data for generating the embeddings
3. It requests OpenAI to generate embeddings
4. It stores the embeddings alongside the data.

## Querying embeddings

Once the embeddings have been generated you can leverage [pgvector](https://github.com/pgvector/pgvector) to perform any operation you may want. In addition, Auto-Embeddings will automatically provide two new queries; `graphiteSearchXXX` (search using natural language) and `graphiteSimilarXXX` (search for objects similar to a given object), where `XXX` is a name given by you.

## Demo

To demonstrate how to configure Auto-Embeddings we will use a sample project located in the [graphite repo](https://github.com/nhost/graphite) you can use to follow along.

If you decide to follow along you will need:

1. Docker
2. Latest [Nhost CLI](https://github.com/nhost/cli)
3. An [OpenAI](https://openai.com) API key.

To start the demo project first edit the file `build/demo-movies/.secrets` and add:

```toml
GRAFANA_ADMIN_PASSWORD = 'grafana-admin-password'
HASURA_GRAPHQL_ADMIN_SECRET = 'nhost-admin-secret'
HASURA_GRAPHQL_JWT_SECRET = '0f987876650b4a085e64594fae9219e7781b17506bec02489ad061fba8cb22db'
NHOST_WEBHOOK_SECRET = 'nhost-webhook-secret'

GRAPHITE_WEBHOOK_SECRET = 'graphite-secret'
OPEANAI_API_KEY = 'HERE_GOES_YOUR_OPENAI_KEY'
```

Then run the following command in the root of the project:

```
make quickstart-movies-up
```

### Project overview

Before we start, let's start by explaining the sample project. Our sample project contains a single table called `movies` with the following columns:

- `id` (uuid)
- `created_at` (timestamptz)
- `updated_at` (timestamptz)
- `name` (text)
- `score` (numeric)
- `genre` (text)
- `overview`(text)
- `crew` (text)
- `budget` (bigint)
- `revenue` (bigint)
- `country` (text)

Our goal is going to be to generate embeddings using the data in the columns `name`, `genre` and `overview`.

### Preparing your database

Before we can start generating embeddings we need to prepare our database:

1. First we are going to need a column to store the embeddings.
2. Finally, we are going to need a mechanism to detect when embeddings need to be regenerated.

#### Embeddings Column

Creating a column to store embeddings is as simple as creating any other column. Just make sure is of type `vector(1536)` and it can be `NULL`. For our sample project we can simply go to the SQL tab and create a migration with the following content:

```sql
-- in this example we are using "embeddings" as the name for our column
-- but you can choose anything you want
ALTER TABLE public.movies ADD COLUMN embeddings vector(1536) NULL;
```

For instance:

![creating embeddings column](/images/guides/ai/auto-embeddings/column.png)

#### Detecting Changes

On every `sync-period` graphite will perform a graphql query to get all the rows that have outdated embeddings. This means we can build this query in a way that:

1. Gets the data we need for the embeddings.
2. Retrieves objects with the embeddings column set to `NULL`.
3. Leverages another mechanism to detect which rows needs their embeddings regenerated.

In this example we are going to opt for the following mechanism to detect outdated embeddings:

1. Add a column `outdated` (boolean) to indicated whether the row is outdated or not.
2. Add a postgres trigger and function that will set the `outdated` column to true everytime there is a change to our data.

With this in mind we are going to create a migration with the following contents:

```sql
-- Add the "outdated" column of type "boolean" with a default value of true
ALTER TABLE "movies" ADD COLUMN "outdated" boolean DEFAULT true;

-- Create a trigger that sets "outdated" to true if the columns
-- "name", "genre" or "overview" are updated
CREATE OR REPLACE FUNCTION set_outdated_trigger()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.name <> OLD.name OR NEW.genre <> OLD.genre OR NEW.overview <> OLD.overview THEN
        NEW.outdated := true;
    ELSEIF NEW.embeddings IS NOT NULL THEN
        NEW.outdated := false;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Attach the trigger to the table
CREATE TRIGGER set_outdated
BEFORE UPDATE ON "movies"
FOR EACH ROW
EXECUTE FUNCTION set_outdated_trigger();
```

For instance:

![outdated mechanism migration](/images/guides/ai/auto-embeddings/outdated.png)

With the previous work in mind, `graphite`'s query will be (more on this later):

```graphql
query GetOutdatedMovies {
  movies(where: {
    _or: [
      {embeddings: {_is_null: true}}, # new rows without embeddings
      {outdated: {_eq: true},         # existing rows with changed data
    },
  ]}) {
    id                                # id column is mandatory
    name
    genre
    overview
  }
}
```

NOTE: This mechanism has the advantage that is simple enough and fully handled by postgres so you don't need to worry about it. In addition, it should be flexible enough to cover most cases. For very complex use-cases you could skip the postgres function and trigger and update the `outdated` directly from your application or you could use some completely different mechanism (i.e. a computed field). The important bit is that graphite needs to be able to make a graphql query and get the relevant rows and data.

### Configuring Auto-Embeddings

Now that we have prepared our database we can proceed to configure Auto-Embeddings. You will need the following data:

1. A unique name. We are going to use `movies` for this particular example but it can be anything. This will determine the name of the GraphQL queries `graphiteSearchXXX` and `graphiteSimilarXXX`.
2. The location of the embeddings column; schema, table and column names, in this example `public`, `movies` and `embeddings` respectively.
3. A GraphQL query to retrieve the outdated rows and their new data (the query we worked on in the previous section)
4. A GraphQL mutation that takes the `id` of the object, the embeddings and that updates the relevant object. For instance, in this particular example the following mutation would suffice:

```graphql
mutation UpdateEmbeddingsMovie($id: uuid!, $embeddings: vector) {
  updateMovie(pk_columns: {id: $id}, _set: {embeddings: $embeddings}) {
    __typename
  }
}
```

NOTE: It is important that the query returns the id of the object and that the mutation accepts it as otherwise graphite won't know which object to update.


Now that we have all the data we need, adding the configuration is as simple as running the following graphql mutation:

```graphql
mutation {
  insertGraphiteAutoEmbeddingsConfiguration(
    object: {
      name: "movies",
      schemaName: "public",
      tableName: "movies",
      columnName: "embeddings",
      query: "query GetOutdatedMovies {   movies(where: {     _or: [       {embeddings: {_is_null: true}},       {outdated: {_eq: true}},     ]}) {     id     name     genre     overview     crew   } }",
      mutation: "mutation UpdateEmbeddingsMovie(   $id: uuid!,   $embeddings: vector, ) {   updateMovie(     pk_columns: {id: $id},     _set: {       embeddings: $embeddings,     }) {     __typename   } }",
    }) {
    id
  }
}
```

For instance:

![auto embeddings configuration mutation](/images/guides/ai/auto-embeddings/configure.png)

After executing the mutation above two things will happen, the queries `graphiteSearchMovies`, `graphiteSearchMoviesAggregate`, `graphiteSimilarMovies` and `graphiteSimilarMoviesAggregate` will be created. These queries will work similar to the standard `movies` and `moviesAggregate` queries provided by hasura and will respect the same permissions but they will also allow you to query movies using natural language or other movies for comparison. For instance:


![auto-embeddings-search](/images/guides/ai/auto-embeddings/search.png)
![auto-embeddings-similar](/images/guides/ai/auto-embeddings/similar.png)

NOTE: The queries in the screenshot above where done using the full demo instead of the quickstart. The quickstart doesn't have enough data to return meaningful results, it is meant for demonstrational purposes without requiring to generate embeddings for thousnds of movies.


The second thing that is going to happen is that if we look at our logs we will start seeing entries like this on the next `sync-period`:


```
Dec 11 15:37:07.674 INF running auto embeddings process component=autoai.auto_embeddings_process
Dec 11 15:37:07.677 INF running job component=autoai.auto_embeddings_process job=movies id=ead63864-93cb-40ac-8e12-dd8e5a094fec
Dec 11 15:37:07.690 INF updating embeddings component=autoai.auto_embeddings_process job=movies id=ead63864-93cb-40ac-8e12-dd8e5a094fec data.id=f47ea1d8-9f9d-4336-8932-294b598dbffb
Dec 11 15:37:08.271 INF updating embeddings component=autoai.auto_embeddings_process job=movies id=ead63864-93cb-40ac-8e12-dd8e5a094fec data.id=8ba30a35-2aaf-4b77-9ce9-6686c895df63
Dec 11 15:37:08.877 INF updating embeddings component=autoai.auto_embeddings_process job=movies id=ead63864-93cb-40ac-8e12-dd8e5a094fec data.id=6df22e39-4076-41b4-b0d6-49d2a51ecdfe
Dec 11 15:37:09.339 INF updating embeddings component=autoai.auto_embeddings_process job=movies id=ead63864-93cb-40ac-8e12-dd8e5a094fec data.id=000294a4-345a-4445-b822-56dfef8a4f91
Dec 11 15:37:09.749 INF updating embeddings component=autoai.auto_embeddings_process job=movies id=ead63864-93cb-40ac-8e12-dd8e5a094fec data.id=0363eafd-4bfb-45ee-96c8-8f0e3205bf37
Dec 11 15:37:10.159 INF updating embeddings component=autoai.auto_embeddings_process job=movies id=ead63864-93cb-40ac-8e12-dd8e5a094fec data.id=5bc778a2-df54-4f8b-bd77-face3dddf9b3
Dec 11 15:37:10.592 INF updating embeddings component=autoai.auto_embeddings_process job=movies id=ead63864-93cb-40ac-8e12-dd8e5a094fec data.id=d051be2b-dd93-4d5d-8f03-0031844d2599
Dec 11 15:37:11.083 INF updating embeddings component=autoai.auto_embeddings_process job=movies id=ead63864-93cb-40ac-8e12-dd8e5a094fec data.id=421057c2-5dae-47bb-b6d2-43c146009c2d
Dec 11 15:37:11.611 INF updating embeddings component=autoai.auto_embeddings_process job=movies id=ead63864-93cb-40ac-8e12-dd8e5a094fec data.id=ddfd2674-a678-4c9c-afbe-23637b4465f1
Dec 11 15:37:12.039 INF updating embeddings component=autoai.auto_embeddings_process job=movies id=ead63864-93cb-40ac-8e12-dd8e5a094fec data.id=c038dfd4-5cdc-4dee-ad64-c02598692123
Dec 11 15:37:12.519 INF updating embeddings component=autoai.auto_embeddings_process job=movies id=ead63864-93cb-40ac-8e12-dd8e5a094fec data.id=087dea55-7681-4637-9e77-7b17e578f8a9
```

The logs indicate that graphite has started to generate embeddings for the movies. We can track the progress by counting movies with the `embeddings` column set to `NULL`:

![auto embeddings count 237](/images/guides/ai/auto-embeddings/count_237.png)

Until eventually it reaches 0.

![auto embeddings count 0](/images/guides/ai/auto-embeddings/count_0.png)
